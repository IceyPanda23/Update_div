# --------------------------------------------------------------
#  update_div.py
# --------------------------------------------------------------
def update_div(localhost=None):
    """
    Compare a staging table with Dividend tables, preview changes,
    then apply updates that mark paid dividends and flag matched rows.
    """

    # ---------------------------------------------------------- #
    # 1. Ensure required modules are present
    # ---------------------------------------------------------- #
    import importlib
    import subprocess
    import sys
    from pathlib import Path

    def ensure_module(pkg, import_name=None):
        import_name = import_name or pkg
        try:
            importlib.import_module(import_name)
        except ImportError:
            print(f"ðŸ” '{import_name}' missing â€“ installing '{pkg}' â€¦")
            subprocess.check_call([sys.executable, "-m", "pip", "install", pkg])

    for pkg in ("pandas", "sqlalchemy", "pyodbc", "openpyxl"):
        ensure_module(pkg)

    import pandas as pd
    from sqlalchemy import create_engine, text

    # ---------------------------------------------------------- #
    # 2. Friend-proof pager: numbered list, no pandas ellipsis
    # ---------------------------------------------------------- #
    def paginate_list(df, page_size=10, prompt="Select item"):
        """
        Display df (first column as label) page by page and return
        the absolute index chosen, or None if user quits.
        """
        full, filt = df.copy(), df.copy()
        page = 0

        while True:
            total = len(filt)
            start, end = page * page_size, min((page + 1) * page_size, total)
            print(f"\nâ–¶ {prompt}  {start}â€“{end - 1} of {total - 1}")
            for rel, (abs_i, row) in enumerate(filt.iloc[start:end].iterrows()):
                print(f"{rel:>3} â”‚ {row.iloc[0]}")

            print("\n[Enter]=next | p=prev | n=index | s:term | r=reset | q=quit")
            cmd = input("Select: ").strip().lower()

            if cmd == "":
                page = page + 1 if end < total else page
            elif cmd == "p":
                page = max(page - 1, 0)
            elif cmd == "r":
                filt, page = full.copy(), 0
            elif cmd.startswith("s:"):
                term = cmd[2:].strip()
                filt, page = (
                    full[full.iloc[:, 0].str.lower().str.contains(term)],
                    0,
                )
            elif cmd == "q":
                return None
            elif cmd.isdigit():
                abs_idx = page * page_size + int(cmd)
                if 0 <= abs_idx < total:
                    return filt.index[abs_idx]
                print("âŒ Invalid index.")
            else:
                print("âŒ Unrecognised input.")

    # ---------------------------------------------------------- #
    # 3. Preview & update worker
    # ---------------------------------------------------------- #
    def run_updates(engine, db_name, table_name, div_list):
        """
        â€¢ Build a preview workbook listing matched / unmatched rows.
        â€¢ Ask user to confirm (optional).
        â€¢ Perform updates & mark matched rows.
        â€¢ Export any still-unmatched rows after the update.
        """
        with engine.begin() as connection:
            # ---------- 3-A  Preview before touching data ----------
            union_parts = [
                "SELECT ShareholderNo, DividendNo FROM Dividend"
                if div_no == 1
                else f"SELECT ShareholderNo, DividendNo FROM Dividend{div_no}"
                for div_no in div_list
            ]
            union_sql = "\nUNION ALL\n".join(union_parts)

            matched_q = f"""
                SELECT src.*
                FROM [{db_name}].[dbo].[{table_name}] src
                INNER JOIN ({union_sql}) tgt
                    ON src.sno   = tgt.ShareholderNo
                   AND src.divno = tgt.DividendNo
            """
            unmatched_q = f"""
                SELECT src.*
                FROM [{db_name}].[dbo].[{table_name}] src
                LEFT JOIN ({union_sql}) tgt
                    ON src.sno   = tgt.ShareholderNo
                   AND src.divno = tgt.DividendNo
                WHERE tgt.ShareholderNo IS NULL
            """

            df_will = pd.read_sql(matched_q, connection)
            df_no   = pd.read_sql(unmatched_q, connection)

            prev_path = f"./DIVS_PREVIEW_{db_name}_{table_name}.xlsx"
            with pd.ExcelWriter(prev_path, engine="openpyxl") as wrt:
                df_will.to_excel(wrt, sheet_name="Will_Update", index=False)
                df_no.to_excel(wrt, sheet_name="No_Match",   index=False)

            print(f"\nðŸ“ Preview saved to {prev_path}")

            # --------- 3-B  (Optional) confirm continue ----------
            go = input("Proceed with updates? (y/n): ").strip().lower()
            if go != "y":
                print("Aborted by user.")
                return

            # ---------- 3-C  Pick payment method ----------
            pay_df = pd.read_sql(
                f"""SELECT Code, Description
                    FROM [{db_name}].[dbo].[DividendPaymentMethods]
                    ORDER BY Description""",
                connection,
            )
            print("Payment methods:")
            pay_idx = paginate_list(pay_df, prompt="Select payment method")
            if pay_idx is None:
                code_in = input("Enter Code manually or 'q' to quit: ").strip()
                if code_in.lower() == "q":
                    print("Exitingâ€¦")
                    return
                pay_code = int(code_in)
                pay_desc = str(pay_code)
            else:
                pay_code = int(pay_df.at[pay_idx, "Code"])
                pay_desc = pay_df.at[pay_idx, "Description"]

        # ---------- 3-D  Apply updates ----------
        succ, fail = [], []
        with engine.begin() as connection:
            for div_no in div_list:
                div_no = int(div_no)
                div_tbl = "Dividend" if div_no == 1 else f"Dividend{div_no}"

                set_clause = (
                    "DividendPaymentDate = src.Date, "
                    "DividendPaymentMethodCode = :pc, "
                    "DividendPaid = 1"
                    if db_name != "EABLDatabaseRegister"
                    else "DividendPaymentDate = src.Date, DividendPaid = 1"
                )

                upd = f"""
                    UPDATE {div_tbl}
                    SET {set_clause}
                    FROM {div_tbl} tgt
                    INNER JOIN {table_name} src
                        ON tgt.ShareholderNo = src.sno
                       AND tgt.DividendNo   = src.divno
                """
                mark = f"""
                    UPDATE {table_name}
                    SET matched = 1
                    FROM {table_name} src
                    INNER JOIN {div_tbl} tgt
                        ON src.sno   = tgt.ShareholderNo
                       AND src.divno = tgt.DividendNo
                """

                try:
                    # connection.execute(text(upd), {"pc": pay_code})  # â† rowcount if needed
                    connection.execute(text(upd), {"pc": pay_code})
                    connection.execute(text(mark))
                    succ.append(div_no)
                except Exception as e:
                    print(f"âŒ Dividend{div_no} failed: {e}")
                    fail.append(div_no)

        print("\nâœ… Updated:", succ or "None")
        print("âŒ Failed :", fail or "None")

        # ---------- 3-E  Export rows still unmatched ----------
        with engine.begin() as conn:
            df_out = pd.read_sql(
                f"""SELECT * FROM [{db_name}].[dbo].[{table_name}]
                    WHERE matched IS NULL""",
                conn,
            )
        out_path = f"./DIVS_NOT_UPDATED_{db_name}_{pay_desc}.xlsx"
        df_out.to_excel(out_path, engine="openpyxl")
        print(f"ðŸ“„ Post-update unmatched rows â†’ {out_path}")

    # ---------------------------------------------------------- #
    # 4. Top-level: connect, pick DB & table, launch run_updates
    # ---------------------------------------------------------- #
    try:
        # ---- 4-A  Local or remote? ----
        if localhost is None:
            localhost = input("Use localhost SQL Server? (y/n): ").lower() == "y"

        if localhost:
            engine = create_engine(
                "mssql+pyodbc://localhost/master?driver=ODBC+Driver+17+for+SQL+Server&trusted_connection=yes"
            )
            db_df = pd.read_sql(
                "SELECT name FROM sys.databases "
                "WHERE name NOT IN ('master','tempdb','model','msdb')",
                engine,
            )
            idx = paginate_list(db_df, prompt="Select database")
            if idx is None:
                db_name = input("DB name (or 'q'): ").strip()
                if db_name.lower() == "q":
                    return
            else:
                db_name = db_df.iat[idx, 0]

            conn_str = (
                f"mssql+pyodbc://localhost/{db_name}"
                "?driver=ODBC+Driver+17+for+SQL+Server&trusted_connection=yes"
            )

        else:
            creds_path = Path(__file__).resolve().parent / "server_credentials.csv"
            saved = pd.read_csv(creds_path)
            print("Saved servers:")
            print(saved["Server_ip"])
            sel = input("Pick number or 'new': ").strip().lower()

            if sel == "new":
                ip, user, pw = (
                    input("IP: "),
                    input("Username: "),
                    input("Password: "),
                )
            else:
                rec = saved.iloc[int(sel)]
                ip, user, pw = rec["Server_ip"], rec["Username"], rec["Password"]

            conn_str = (
                f"mssql+pyodbc://{user}:{pw}@{ip}/master?"
                "Driver=ODBC+Driver+17+for+SQL+Server"
            )
            engine = create_engine(conn_str)
            db_df = pd.read_sql(
                "SELECT name FROM sys.databases "
                "WHERE name NOT IN ('master','tempdb','model','msdb')",
                engine,
            )
            idx = paginate_list(db_df, prompt="Select database")
            if idx is None:
                db_name = input("DB name (or 'q'): ").strip()
                if db_name.lower() == "q":
                    return
            else:
                db_name = db_df.iat[idx, 0]

            conn_str = (
                f"mssql+pyodbc://{user}:{pw}@{ip}/{db_name}?"
                "Driver=ODBC+Driver+17+for+SQL+Server"
            )

        # ---- 4-B  Choose table ----
        engine = create_engine(conn_str)
        tbl_df = pd.read_sql(
            "SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES "
            "WHERE TABLE_TYPE='BASE TABLE'",
            engine,
        )
        tbl_idx = paginate_list(tbl_df, prompt="Connect tables")
        if tbl_idx is None:
            table_name = input("Table name (or 'q'): ").strip()
            if table_name.lower() == "q":
                return
        else:
            table_name = tbl_df.iat[tbl_idx, 0]

        # ---- 4-C  Dividend numbers present in that table ----
        with engine.begin() as conn:
            div_list = [
                row[0]
                for row in conn.execute(
                    text(
                        f"SELECT DIVNO FROM [{db_name}].[dbo].[{table_name}] "
                        "GROUP BY DIVNO"
                    )
                )
                if row[0] is not None
            ]

        print("Dividend list:", div_list)
        run_updates(engine, db_name, table_name, div_list)

    except Exception as exc:
        print(f"\nâŒ Error: {exc}")
        input("\nPress any key to exitâ€¦")
    else:
        input("\nâœ”ï¸  Done â€“ press any key to exitâ€¦")


# --------------------------------------------------------------
# 5. Execute
# --------------------------------------------------------------
if __name__ == "__main__":
    update_div()